def maze_module():
    """Модуль лабиринтов"""
    print("\n" + "=" * 50)
    print("МОДУЛЬ: ЛАБИРИНТЫ")
    print("=" * 50)
    
    # Определение всех 9 лабиринтов
    # Ключ: frozenset с двумя кружочками для учета любого порядка ввода
    mazes = {}
    
    # Лабиринт 1: кружочки в (1,2) и (6,4)
    mazes[frozenset([(1, 2), (6, 4)])] = {
        'h_walls': {(2, 1), (2, 5), (2, 6), (3, 2), (3, 3), (3, 4), (4, 1), (4, 5), (5, 3), (5, 4), (6, 2), (6, 6)},
        'v_walls': {(1, 2), (1, 4), (1, 5), (2, 1), (2, 3), (3, 3), (3, 6), (4, 2), (4, 4), (5, 1), (5, 5), (5, 6), (6, 3), (6, 4)}
    }
    
    # Лабиринт 2: кружочки в (2,1) и (5,4)
    mazes[frozenset([(2, 1), (5, 4)])] = {
        'h_walls': {(2, 2), (2, 3), (2, 4), (3, 1), (3, 5), (3, 6), (4, 2), (4, 3), (5, 1), (5, 5), (6, 3), (6, 4), (6, 6)},
        'v_walls': {(1, 1), (1, 3), (1, 4), (2, 2), (2, 6), (3, 4), (3, 5), (4, 1), (4, 3), (5, 2), (5, 5), (5, 6), (6, 4)}
    }
    
    # Лабиринт 3: кружочки в (1,6) и (4,5)
    mazes[frozenset([(1, 6), (4, 5)])] = {
        'h_walls': {(2, 1), (2, 2), (2, 4), (3, 3), (3, 5), (3, 6), (4, 1), (4, 4), (5, 2), (5, 3), (6, 4), (6, 5), (6, 6)},
        'v_walls': {(1, 2), (1, 5), (2, 1), (2, 4), (2, 6), (3, 2), (3, 3), (4, 5), (5, 1), (5, 3), (5, 4), (6, 2), (6, 6)}
    }
    
    # Лабиринт 4: кружочки в (2,4) и (3,1)
    mazes[frozenset([(2, 4), (3, 1)])] = {
        'h_walls': {(2, 2), (2, 3), (2, 6), (3, 1), (3, 4), (3, 5), (4, 2), (4, 6), (5, 1), (5, 3), (5, 4), (5, 5), (6, 2)},
        'v_walls': {(1, 1), (1, 4), (2, 3), (2, 5), (3, 2), (3, 6), (4, 1), (4, 4), (4, 5), (5, 2), (5, 6), (6, 3), (6, 4)}
    }
    
    # Лабиринт 5: кружочки в (3,5) и (4,2)
    mazes[frozenset([(3, 5), (4, 2)])] = {
        'h_walls': {(2, 1), (2, 4), (2, 5), (3, 2), (3, 3), (3, 6), (4, 1), (4, 4), (4, 5), (5, 2), (5, 6), (6, 3), (6, 4), (6, 5)},
        'v_walls': {(1, 3), (1, 5), (2, 1), (2, 2), (2, 4), (3, 3), (3, 6), (4, 2), (4, 5), (5, 1), (5, 4), (5, 5), (6, 6)}
    }
    
    # Лабиринт 6: кружочки в (4,3) и (5,6)
    mazes[frozenset([(4, 3), (5, 6)])] = {
        'h_walls': {(2, 2), (2, 3), (2, 4), (3, 1), (3, 5), (3, 6), (4, 2), (4, 4), (5, 1), (5, 3), (5, 5), (6, 2), (6, 4), (6, 6)},
        'v_walls': {(1, 2), (1, 4), (1, 6), (2, 1), (2, 5), (3, 3), (3, 4), (4, 1), (4, 6), (5, 2), (5, 4), (6, 3), (6, 5)}
    }
    
    # Лабиринт 7: кружочки в (1,1) и (4,4)
    mazes[frozenset([(1, 1), (4, 4)])] = {
        'h_walls': {(2, 2), (2, 3), (2, 5), (3, 1), (3, 4), (3, 6), (4, 2), (4, 3), (4, 5), (5, 1), (5, 4), (5, 6), (6, 3), (6, 5)},
        'v_walls': {(1, 2), (1, 3), (1, 6), (2, 1), (2, 4), (3, 2), (3, 5), (4, 3), (4, 4), (4, 6), (5, 2), (5, 5), (6, 1), (6, 4)}
    }
    
    # Лабиринт 8: кружочки в (2,6) и (6,3)
    mazes[frozenset([(2, 6), (6, 3)])] = {
        'h_walls': {(2, 1), (2, 2), (2, 4), (3, 3), (3, 5), (3, 6), (4, 1), (4, 2), (4, 4), (5, 3), (5, 5), (5, 6), (6, 1), (6, 4)},
        'v_walls': {(1, 1), (1, 3), (1, 5), (2, 2), (2, 4), (2, 6), (3, 1), (3, 4), (4, 3), (4, 5), (5, 2), (5, 4), (5, 6), (6, 5)}
    }
    
    # Лабиринт 9: кружочки в (3,2) и (5,5)
    mazes[frozenset([(3, 2), (5, 5)])] = {
        'h_walls': {(2, 1), (2, 3), (2, 4), (3, 2), (3, 5), (3, 6), (4, 1), (4, 3), (4, 4), (5, 2), (5, 5), (6, 1), (6, 3), (6, 6)},
        'v_walls': {(1, 2), (1, 4), (1, 5), (2, 1), (2, 3), (2, 6), (3, 4), (3, 5), (4, 2), (4, 5), (4, 6), (5, 1), (5, 3), (6, 2), (6, 4)}
    }
    
    print("\nВведите позиции кружочков на модуле.")
    print("Формат: ряд колонка (например: 1 5)")
    print("Ряды идут сверху вниз (1-6), колонки слева направо (1-6)\n")
    
    # Ввод позиций кружочков
    while True:
        try:
            circle1 = input("Первый кружочек (ряд колонка): ").strip().split()
            r1, c1 = int(circle1[0]), int(circle1[1])
            if 1 <= r1 <= 6 and 1 <= c1 <= 6:
                break
            print("⚠ Координаты должны быть от 1 до 6!")
        except:
            print("⚠ Неверный формат! Введите два числа через пробел")
    
    while True:
        try:
            circle2 = input("Второй кружочек (ряд колонка): ").strip().split()
            r2, c2 = int(circle2[0]), int(circle2[1])
            if 1 <= r2 <= 6 and 1 <= c2 <= 6:
                break
            print("⚠ Координаты должны быть от 1 до 6!")
        except:
            print("⚠ Неверный формат! Введите два числа через пробел")
    
    # Определяем лабиринт
    maze_key = frozenset([(r1, c1), (r2, c2)])
    
    if maze_key not in mazes:
        print("\n⚠ Лабиринт с такими кружочками не найден!")
        print("Проверьте правильность ввода координат")
        print("\nДоступные комбинации кружочков:")
        print("  (1,2) и (6,4)")
        print("  (2,1) и (5,4)")
        print("  (1,6) и (4,5)")
        print("  (2,4) и (3,1)")
        print("  (3,5) и (4,2)")
        print("  (4,3) и (5,6)")
        print("  (1,1) и (4,4)")
        print("  (2,6) и (6,3)")
        print("  (3,2) и (5,5)")
        input("\nНажмите Enter для возврата в меню...")
        return
    
    maze = mazes[maze_key]
    print(f"\n✓ Лабиринт найден! Кружочки: ({r1},{c1}) и ({r2},{c2})")
    
    # Ввод текущей позиции и цели
    while True:
        try:
            start = input("\nВаша текущая позиция (ряд колонка): ").strip().split()
            start_r, start_c = int(start[0]), int(start[1])
            if 1 <= start_r <= 6 and 1 <= start_c <= 6:
                break
            print("⚠ Координаты должны быть от 1 до 6!")
        except:
            print("⚠ Неверный формат! Введите два числа через пробел")
    
    while True:
        try:
            goal = input("Целевая позиция (ряд колонка): ").strip().split()
            goal_r, goal_c = int(goal[0]), int(goal[1])
            if 1 <= goal_r <= 6 and 1 <= goal_c <= 6:
                break
            print("⚠ Координаты должны быть от 1 до 6!")
        except:
            print("⚠ Неверный формат! Введите два числа через пробел")
    
    # Поиск пути (BFS)
    from collections import deque
    
    def can_move(from_r, from_c, to_r, to_c, maze):
        """Проверяет, можно ли переместиться из одной клетки в другую"""
        if to_r < 1 or to_r > 6 or to_c < 1 or to_c > 6:
            return False
        
        # Проверяем стены
        if to_r == from_r - 1:  # Вверх
            return (from_r, from_c) not in maze['h_walls']
        elif to_r == from_r + 1:  # Вниз
            return (to_r, to_c) not in maze['h_walls']
        elif to_c == from_c - 1:  # Влево
            return (from_r, from_c) not in maze['v_walls']
        elif to_c == from_c + 1:  # Вправо
            return (from_r, to_c) not in maze['v_walls']
        return False
    
    # BFS для поиска кратчайшего пути
    queue = deque([(start_r, start_c, [])])
    visited = {(start_r, start_c)}
    
    while queue:
        r, c, path = queue.popleft()
        
        if r == goal_r and c == goal_c:
            # Путь найден!
            print("\n" + "=" * 50)
            print("ПУТЬ НАЙДЕН!")
            print("=" * 50)
            
            if not path:
                print("\n✓ Вы уже на месте!")
            else:
                print(f"\nШагов: {len(path)}")
                print("\nПуть:")
                for i, direction in enumerate(path, 1):
                    print(f"  {i}. {direction}")
            
            print("\n" + "=" * 50)
            input("\nНажмите Enter для возврата в меню...")
            return
        
        # Проверяем все направления
        moves = [
            (-1, 0, "ВВЕРХ"),
            (1, 0, "ВНИЗ"),
            (0, -1, "ВЛЕВО"),
            (0, 1, "ВПРАВО")
        ]
        
        for dr, dc, direction in moves:
            new_r, new_c = r + dr, c + dc
            if (new_r, new_c) not in visited and can_move(r, c, new_r, new_c, maze):
                visited.add((new_r, new_c))
                queue.append((new_r, new_c, path + [direction]))
    
    # Путь не найден
    print("\n" + "=" * 50)
    print("⚠ ПУТЬ НЕ НАЙДЕН!")
    print("Проверьте правильность введенных координат")
    print("=" * 50)
    input("\nНажмите Enter для возврата в меню...")